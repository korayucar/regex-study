package xyz.korayucar.regex;

import org.junit.jupiter.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/*
 * This Java source file was auto generated by running 'gradle init --type java-library'
 * by 'koray2' at '7/25/16 4:02 PM' with Gradle 2.12
 *
 * @author koray2, @date 7/25/16 4:02 PM
 */
@Tag("fast")
class RegexLearningTest {
    
    public final Logger LOG = LoggerFactory.getLogger(getClass());
    
    RegexLearning regex;
    
    @BeforeEach
    void initializeRegexLearning(TestInfo testInfo) {
        regex = new RegexLearning();
        String displayName = testInfo.getDisplayName();
        LOG.info("\n");
        LOG.info("running: {}", displayName);
    }
    
    
    @Test
    @DisplayName("Simple number matching test")
    void findNumberOccurencesTest() {
        regex.findOccurences("\\d", "12341");
        
    }
    
    @Test
    @DisplayName("Another Simple number range matching test")
    void findNumberRangeOccuranceTest() {
        regex.findOccurences("[4-7]", "1823656");
        
    }
    
    
    @Test
    @DisplayName("Simple text matching")
    void simpleTextMatchTest() {
        regex.findOccurences("foo", "goofoofoodoo");
        
    }
    
    
    @Test
    @DisplayName("Character set negation. Note matching of space character.")
    void characterSetNegationTest() {
        regex.findOccurences("[^ch]at", "cat sat at that hat");
        
    }
    
    @Test
    @DisplayName("Character set union. Negation preceedes union operation.")
    void characterSetUnionExample() {
        regex.findOccurences("[^ch[a-d]]at", "bat sat at that hat");
        
    }
    
    @Test
    @DisplayName("Character set union. characters that are not c and h or characters that are not between a and d. Only excludes cat.")
    void characterSetUnionExample2() {
        regex.findOccurences("[^ch[^a-d]]at", "bat cat aat that hat");
        
    }
    
    
    @Test
    @DisplayName("Character set intersection. The intersection is only 1 and 8.")
    void characterSetIntersection() {
        regex.findOccurences("[[0189]&&[1-8]]", "11223344556677889900");
        
    }
    
    @Test
    @DisplayName("Character set difference. The intersection is only 0 and 9.")
    void characterSetDifference() {
        regex.findOccurences("[[0189]&&[^1-8]]", "11223344556677889900");
    }
    
    @Test
    @DisplayName("Dot character matching")
    void dotCharMatchTest() {
        regex.findOccurences("cat.", "cats");
        
    }
    
    @Test
    @DisplayName("Number character `\\d` matching")
    void numberCharMatchTest() {
        regex.findOccurences("\\dcat", "123cat");
        
    }
    
    @Test
    @DisplayName("Space character `\\s` matching")
    void spaceCharMatchTest() {
        regex.findOccurences("\\d\\scat", "123 cat");
        
    }
    
    
    @Test
    @DisplayName("Space character `\\w` matching")
    void alphanumericCharMatchTest() {
        regex.findOccurences("\\d\\wcat", "123 cat");
        regex.findOccurences("\\wat", "123 cat");
        
    }
    
    
    /**
     * Uses the greedy quantifier .* to find "anything", zero or more times, followed by the letters
     * "f" "o" "o". Because the quantifier is greedy, the .* portion of the expression first eats the entire input 
     * string. At this point, the overall expression cannot succeed, because the last three letters 
     * ("f" "o" "o") have already been consumed. So the matcher slowly backs off one letter at a time until the 
     * rightmost occurrence of "foo" has been regurgitated, at which point the match succeeds and the search ends.
     */
    @Test
    @DisplayName("see http://stackoverflow.com/a/5319978/3890849 Greedy match context. Finds single greedy match.")
    void greedyTest() {
        regex.findOccurences(".*foo", "xfooxxxxxxfoo");
    }
    
    
    /**
     * it starts by first consuming "nothing". Because "foo" doesn't appear at the beginning of the string, 
     * it's forced to swallow the first letter (an "x"), which triggers the first match at 0 and 4. 
     * Our test harness continues the process until the input string is exhausted. It finds another match at 4 and 13.
     */
    @Test
    @DisplayName("see http://stackoverflow.com/a/5319978/3890849 Reluctant matching. Finds 2 matches. Note that it does not find entire string.")
    void reluctantTest() {
        regex.findOccurences(".*?foo", "xfooxxxxxxfoo");
    }
 
    @Test
    @DisplayName("Another reluctant matching.")
    void reluctantTest2() {
        regex.findOccurences(".??foo", "xfooxxxxxxfoo");
    }
 
    
    /**
     * In this case, the entire input string is consumed by .*+, leaving nothing left over to satisfy the "foo" at 
     * the end of the expression. Use a possessive quantifier for situations where you want to seize all of something 
     * without ever backing off; it will outperform the equivalent greedy quantifier in cases where the match is 
     * not immediately found.
     */
    @Test
    @DisplayName("see http://stackoverflow.com/a/5319978/3890849 Possesive matching.")
    void possesiveTest() {
        regex.findOccurences(".*+foo", "xfooxxxxxxfoo");
    }
    
    @Test
    @DisplayName("Possesive matching. Once or not at all.")
    void possesiveTest2() {
        regex.findOccurences(".?+foo", "xfooxxxxxxfoo");
    }
    
    
    
    
    
    @Test
    @DisplayName("Line start end matching. ^ is line start , $ is line end.")
    void lineStartAndEnd() {
        regex.findOccurences("^dog$", "dog");
    }
    
    
    
    
    
    
}

